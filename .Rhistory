rmse_h21 <- mod$rmse
mod$plot
title <- paste0("Figure ",fig,": Recursive 7-Day Forecasts for All Simulations")
fig <- fig + 1
mod <- single_forecast(rdates, rpreds, days = 7, title = title, res = TRUE)
rmse_r7 <- mod$rmse
mod$plot
knitr::opts_chunk$set(echo = FALSE)
## Complete Outbreak Dataset
## Used to plot the true number of infections over time
rm(list=ls())
true <- read.csv("/Volumes/GoogleDrive/.shortcut-targets-by-id/15UGkfREtfqH3LdfHmCsSpFJ5SrTnSeyt/ebola/2020-05-04_ebola/2020-05-04_data.csv")
source("outbreak_vis.R") #script with functions
rgx <- "\\d{1,2}\\/\\d{1,2}\\/\\d{4}" #date structure regex
true <- true[str_detect(true$Date, rgx),] #omits rows without a date
colnames(true) <- c("date", "cases")
true$date <- mdy(true$date) #converts into a consistent date format
true$cases[is.na(true$cases)] <- 0
true <- true %>% mutate(total = cumsum(cases))
last_date <- true$date[length(true$date)]
last_case <- true$total[length(true$total)]
## Recursive Projections Dataset
rproj <- read.csv("/Volumes/GoogleDrive/.shortcut-targets-by-id/1LaD1nL_OAOposW2fr2XDcs6BLHVBC-jA/2019 Ebola/Post-Outbreak Analysis/recursive_post_proj.csv") #forecasted values
rproj <- rproj %>% select(date_last_case, pred.7, pred.14, pred.21)
rproj$date_last_case <- mdy(rproj$date_last_case)
rproj <- na.omit(rproj) # some dates have no projections
rdates <- as.character(rproj$date_last_case)
rpreds <- t(rproj %>% select(pred.7,pred.14,pred.21))
omit_h <- c(8,17,22,33,47:49,51,52,55,56,60,64,69,77) #omit hrom Hawkes because Recursive has no data for these dates
## Hawkes Projections Dataset
hproj <- read.csv("/Volumes/GoogleDrive/.shortcut-targets-by-id/1LaD1nL_OAOposW2fr2XDcs6BLHVBC-jA/2019 Ebola/Post-Outbreak Analysis/hawkes_post_proj.csv") #forecasted values
hproj <- hproj %>% select(date_last_case, pred.7, pred.14, pred.21) #selecting only the cols with forecasts
hproj$date_last_case <- mdy(hproj$date_last_case)
hproj <- hproj[-omit_h,] #omit the rows that aren't also in recursive
hdates <- as.character(hproj$date_last_case) #for working with dates
hpreds <- t(hproj %>% select(pred.7,pred.14,pred.21)) #take t() for the function
rownames(hproj) <- 1:nrow(hproj)
fig <- 1 # for numbering the figures in the plots
title <- paste0("Figure ",fig,": Hawkes 7-Day Forecasts for All Simulations")
fig <- fig + 1
mod <- single_forecast(hdates, hpreds, days = 7,  title = title, res = TRUE)
rmse_h7 <- mod$rmse
mod$plot
mod$results
fig <- 1 # for numbering the figures in the plots
title <- paste0("Figure ",fig,": Hawkes 7-Day Forecasts for All Simulations")
fig <- fig + 1
mod <- single_forecast(hdates, hpreds, days = 7,  title = title, res = TRUE)
rmse_h7 <- mod$rmse
mod$plot
mod$results
View(hproj)
mod$results
title <- paste0("Figure ",fig,": Hawkes 14-Day Forecasts for All Simulations")
fig <- fig + 1
mod <- single_forecast(hdates, hpreds, days = 14, title = title, res = TRUE)
rmse_h14 <- mod$rmse
mod$plot
mod$results
hdates_o
source('~/Desktop/Git/Ebola-Forecasting/Post Outbreak/outbreak_vis.R', echo=TRUE)
knitr::opts_chunk$set(echo = FALSE)
## Complete Outbreak Dataset
## Used to plot the true number of infections over time
rm(list=ls())
true <- read.csv("/Volumes/GoogleDrive/.shortcut-targets-by-id/15UGkfREtfqH3LdfHmCsSpFJ5SrTnSeyt/ebola/2020-05-04_ebola/2020-05-04_data.csv")
source("outbreak_vis.R") #script with functions
rgx <- "\\d{1,2}\\/\\d{1,2}\\/\\d{4}" #date structure regex
true <- true[str_detect(true$Date, rgx),] #omits rows without a date
colnames(true) <- c("date", "cases")
true$date <- mdy(true$date) #converts into a consistent date format
true$cases[is.na(true$cases)] <- 0
true <- true %>% mutate(total = cumsum(cases))
last_date <- true$date[length(true$date)]
last_case <- true$total[length(true$total)]
## Recursive Projections Dataset
rproj <- read.csv("/Volumes/GoogleDrive/.shortcut-targets-by-id/1LaD1nL_OAOposW2fr2XDcs6BLHVBC-jA/2019 Ebola/Post-Outbreak Analysis/recursive_post_proj.csv") #forecasted values
rproj <- rproj %>% select(date_last_case, pred.7, pred.14, pred.21)
rproj$date_last_case <- mdy(rproj$date_last_case)
rproj <- na.omit(rproj) # some dates have no projections
rdates <- as.character(rproj$date_last_case)
rpreds <- t(rproj %>% select(pred.7,pred.14,pred.21))
omit_h <- c(8,17,22,33,47:49,51,52,55,56,60,64,69,77) #omit hrom Hawkes because Recursive has no data for these dates
## Hawkes Projections Dataset
hproj <- read.csv("/Volumes/GoogleDrive/.shortcut-targets-by-id/1LaD1nL_OAOposW2fr2XDcs6BLHVBC-jA/2019 Ebola/Post-Outbreak Analysis/hawkes_post_proj.csv") #forecasted values
hproj <- hproj %>% select(date_last_case, pred.7, pred.14, pred.21) #selecting only the cols with forecasts
hproj$date_last_case <- mdy(hproj$date_last_case)
hproj <- hproj[-omit_h,] #omit the rows that aren't also in recursive
hdates <- as.character(hproj$date_last_case) #for working with dates
hpreds <- t(hproj %>% select(pred.7,pred.14,pred.21)) #take t() for the function
rownames(hproj) <- 1:nrow(hproj)
fig <- 1 # for numbering the figures in the plots
title <- paste0("Figure ",fig,": Hawkes 7-Day Forecasts for All Simulations")
fig <- fig + 1
mod <- single_forecast(hdates, hpreds, days = 7,  title = title, res = TRUE)
rmse_h7 <- mod$rmse
mod$plot
title <- paste0("Figure ",fig,": Hawkes 14-Day Forecasts for All Simulations")
fig <- fig + 1
mod <- single_forecast(hdates, hpreds, days = 14, title = title, res = TRUE)
rmse_h14 <- mod$rmse
mod$plot
title <- paste0("Figure ",fig,": Hawkes 21-Day Forecasts for All Simulations")
fig <- fig + 1
mod <- single_forecast(hdates, hpreds, days = 21,  title = title, res = TRUE)
rmse_h21 <- mod$rmse
mod$plot
title <- paste0("Figure ",fig,": Recursive 7-Day Forecasts for All Simulations")
fig <- fig + 1
mod <- single_forecast(rdates, rpreds, days = 7, title = title, res = TRUE)
rmse_r7 <- mod$rmse
mod$plot
title <- paste0("Figure ",fig,": Recursive 14-Day Forecasts for All Simulations")
fig <- fig + 1
mod <- single_forecast(rdates, rpreds, days = 14, title = title, res = TRUE)
rmse_r14 <- mod$rmse
mod$plot
title <- paste0("Figure ",fig,": Recursive 7-Day Forecasts for All Simulations")
fig <- fig + 1
mod <- single_forecast(rdates, rpreds, days = 21, title = title, res = TRUE)
rmse_r21 <- mod$rmse
mod$plot
caption <- paste0("RMSE values for Hawkes and Recursive Models for all simulations.")
df_rmse <- data.frame(
"Hawkes" = c(rmse_h7, rmse_h14, rmse_h21),
"Recursive" = c(rmse_r7, rmse_r14, rmse_r21)
)
row.names(df_rmse) <- c("7-day","14-day","21-day")
tbl1<-df_rmse %>% kable(digits = 2, caption = caption) #creates a table with RMSE values
tbl1
rownames(rproj) <- 1:nrow(rproj)
dup_omit <- c(
4:5,7:9,12,14,18,20,22,24,27,32,36,39,41,44,47:48,53,63,64,70,72:73,75:76,
78:80,85,88:89,92:93,97,102,104,106:107,109:111,112,117,122:123,125,128:129,
133,136,162
) #entries with duplicate dates
hproj_omit <- hproj[-dup_omit,]
hdates_o <- hproj_omit$date_last_case
hpreds_o <- t(hproj_omit %>% select(pred.7,pred.14,pred.21))
rproj_omit <- rproj[-dup_omit,]
rdates_o <- rproj_omit$date_last_case
rpreds_o <- t(rproj_omit %>% select(pred.7,pred.14,pred.21))
title <- paste0("Figure ",fig,": Hawkes 7-Day Forecasts for Refined Simulations")
fig <- fig + 1
mod7h <- single_forecast(hdates_o, hpreds_o, days = 7, title = title)
mod7h$plot
title <- paste0("Figure ",fig,": Hawkes 14-Day Forecasts for Refined Simulations")
fig <- fig + 1
mod14h <- single_forecast(hdates_o, hpreds_o, days = 14, title = title)
mod14h$plot
title <- paste0("Figure ",fig,": Hawkes 21-Day Forecasts for Refined Simulations")
fig <- fig + 1
mod21h <- single_forecast(hdates_o, hpreds_o, days = 21, title = title)
mod21h$plot
title <- paste0("Figure ",fig,": Recursive 7-Day Forecasts for Refined Simulations")
fig <- fig + 1
mod7r <- single_forecast(rdates_o, rpreds_o, days = 7, title = title)
mod7r$plot
title <- paste0("Figure ",fig,": Recursive 14-Day Forecasts for Refined Simulations")
fig <- fig + 1
mod14r <- single_forecast(rdates_o, rpreds_o, days = 14, title = title)
mod14r$plot
title <- paste0("Figure ",fig,": Recursive 21-Day Forecasts for Refined Simulations")
fig <- fig + 1
mod21r <- single_forecast(rdates_o, rpreds_o, days = 21, title = title)
mod21r$plot
caption <- paste0("RMSE values for Hawkes and Recursive Models for refined simulations.")
df_rmse <- data.frame(
"Hawkes" = c(mod7h$rmse, mod14h$rmse, mod21h$rmse),
"Recursive" = c(mod7r$rmse, mod14r$rmse, mod21r$rmse)
)
row.names(df_rmse) <- c("7-day","14-day","21-day")
tbl2<-df_rmse %>% kable(digits = 2, caption = caption) #creates a table with RMSE values
tbl2
hdates
hpreds
hdates_o
hdates_o
hdates
rownames(rproj) <- 1:nrow(rproj)
dup_omit <- c(
4:5,7:9,12,14,18,20,22,24,27,32,36,39,41,44,47:48,53,63,64,70,72:73,75:76,
78:80,85,88:89,92:93,97,102,104,106:107,109:111,112,117,122:123,125,128:129,
133,136,162
) #entries with duplicate dates
hproj_omit <- hproj[-dup_omit,]
hdates_o <- as.character(hproj_omit$date_last_case)
hpreds_o <- t(hproj_omit %>% select(pred.7,pred.14,pred.21))
rproj_omit <- rproj[-dup_omit,]
rdates_o <- as.character(rproj_omit$date_last_case)
rpreds_o <- t(rproj_omit %>% select(pred.7,pred.14,pred.21))
title <- paste0("Figure ",fig,": Hawkes 7-Day Forecasts for Refined Simulations")
fig <- fig + 1
mod7h <- single_forecast(hdates_o, hpreds_o, days = 7, title = title)
mod7h$plot
mod7h$results
hpreds_o
mod21r$results
title <- paste0("Figure ",fig,": Recursive 21-Day Forecasts for Refined Simulations")
fig <- fig + 1
mod21r <- single_forecast(rdates_o, rpreds_o, days = 21, title = title)
mod21r$plot
mod21r$results
View(rproj_omit)
View(true)
library(TBASS)
# rmarkdown::html_vignette
fig <- 1
sigma <- 1 # TRUE noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*5), nrow = n, ncol = 5)
y <- rnorm(n, mean = f(x), sd = sigma)
f <- function(x){
10*sin(pi*x[,1]*x[,2]) + 20*(x[,3]-.5)^2 + 10*x[,4] + 5*x[,5]
}
sigma <- 1 # TRUE noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*5), nrow = n, ncol = 5)
y <- rnorm(n, mean = f(x), sd = sigma)
ind<-sample(n,size=10)
y[ind]<-rnorm(5,f(x[ind,]),15)
col<-rep(1,n)
col[ind]<-2
knitr::opts_chunk$set(
collapse = TRUE,
echo = TRUE,
comment = "#>"
)
library(TBASS)
# rmarkdown::html_vignette
fig <- 1
n <- 300
x <- seq(0,1,length.out=n)
y <- sin(2 * pi * x^2) * 10 + rnorm(n)
plot(x,y,main=paste0("Figure ",fig," : Univariate Nonlinear Data"))
fig <- fig + 1
generate_spline <- function(tvec, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis functions
}
mBmat <- t(Bmat)
mod <- lm(y ~ mBmat) #use gibbs to sample coefs in bayes
pred <- predict(mod)
plot(x,y,main=paste0("Figure ",fig," : Univariate Spline Function"))
lines(x, pred, type = "l", lwd = 5, col="blue1")
#list(basis=mBmat)
}
t <- c(0, 0.525, 0.875); generate_spline(t)
set.seed(12)
library(TBASS)
f <- function(x){
10*sin(pi*x[,1]*x[,2]) + 20*(x[,3]-.5)^2 + 10*x[,4] + 5*x[,5]
}
sigma <- 1 # TRUE noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*5), nrow = n, ncol = 5)
y <- rnorm(n, mean = f(x), sd = sigma)
ind <- sample(n,size=10) # convert 10 points to outliers
y[ind] <- rnorm(5, f(x[ind,]), 15)
col <- rep(1,n) # for coloring these points in a later plot
col[ind] <- 2
nmcmc <- 10000 #number of iterations
tb <- tbass(x, y, nu = 10, nmcmc = nmcmc, verbose = TRUE)
knitr::opts_chunk$set(
collapse = TRUE,
echo = TRUE,
comment = "#>"
)
library(TBASS)
# rmarkdown::html_vignette
fig <- 1
n <- 300
x <- seq(0,1,length.out=n)
y <- sin(2 * pi * x^2) * 10 + rnorm(n)
plot(x,y,main=paste0("Figure ",fig," : Univariate Nonlinear Data"))
fig <- fig + 1
generate_spline <- function(tvec, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis functions
}
mBmat <- t(Bmat)
mod <- lm(y ~ mBmat) #use gibbs to sample coefs in bayes
pred <- predict(mod)
plot(x,y,main=paste0("Figure ",fig," : Univariate Spline Function"))
lines(x, pred, type = "l", lwd = 5, col="blue1")
#list(basis=mBmat)
}
t <- c(0, 0.525, 0.875); generate_spline(t)
set.seed(12)
library(TBASS)
f <- function(x){
10*sin(pi*x[,1]*x[,2]) + 20*(x[,3]-.5)^2 + 10*x[,4] + 5*x[,5]
}
sigma <- 1 # TRUE noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*5), nrow = n, ncol = 5)
y <- rnorm(n, mean = f(x), sd = sigma)
ind <- sample(n,size=10) # convert 10 points to outliers
y[ind] <- rnorm(5, f(x[ind,]), 15)
col <- rep(1,n) # for coloring these points in a later plot
col[ind] <- 2
nmcmc <- 10000 #number of iterations
tb <- tbass(x, y, nu = 10, nmcmc = nmcmc, verbose = TRUE)
knitr::opts_chunk$set(
collapse = TRUE,
echo = TRUE,
comment = "#>"
)
library(TBASS)
# rmarkdown::html_vignette
fig <- 1
n <- 300
x <- seq(0,1,length.out=n)
y <- sin(2 * pi * x^2) * 10 + rnorm(n)
plot(x,y,main=paste0("Figure ",fig," : Univariate Nonlinear Data"))
fig <- fig + 1
generate_spline <- function(tvec, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis functions
}
mBmat <- t(Bmat)
mod <- lm(y ~ mBmat) #use gibbs to sample coefs in bayes
pred <- predict(mod)
plot(x,y,main=paste0("Figure ",fig," : Univariate Spline Function"))
lines(x, pred, type = "l", lwd = 5, col="blue1")
#list(basis=mBmat)
}
t <- c(0, 0.525, 0.875); generate_spline(t)
set.seed(12)
library(TBASS)
f <- function(x){
10*sin(pi*x[,1]*x[,2]) + 20*(x[,3]-.5)^2 + 10*x[,4] + 5*x[,5]
}
sigma <- 1 # TRUE noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*5), nrow = n, ncol = 5)
y <- rnorm(n, mean = f(x), sd = sigma)
ind <- sample(n,size=10) # convert 10 points to outliers
y[ind] <- rnorm(5, f(x[ind,]), 15)
col <- rep(1,n) # for coloring these points in a later plot
col[ind] <- 2
nmcmc <- 1000 #number of iterations
tb <- tbass(x, y, nu = 10, nmcmc = nmcmc, verbose = TRUE)
##------ Fri Aug 28 15:18:52 2020 ------##
##------ Fri Aug 28 15:18:56 2020 ------##
##------ Fri Aug 28 15:18:59 2020 ------##
##------ Fri Aug 28 15:19:02 2020 ------##
##------ Fri Aug 28 15:19:05 2020 ------##
##------ Fri Aug 28 15:19:08 2020 ------##
knitr::opts_chunk$set(
collapse = TRUE,
echo = TRUE,
comment = "#>"
)
library(TBASS)
# rmarkdown::html_vignette
fig <- 1
n <- 300
x <- seq(0,1,length.out=n)
y <- sin(2 * pi * x^2) * 10 + rnorm(n)
plot(x,y,main=paste0("Figure ",fig," : Univariate Nonlinear Data"))
fig <- fig + 1
generate_spline <- function(tvec, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis functions
}
mBmat <- t(Bmat)
mod <- lm(y ~ mBmat) #use gibbs to sample coefs in bayes
pred <- predict(mod)
plot(x,y,main=paste0("Figure ",fig," : Univariate Spline Function"))
lines(x, pred, type = "l", lwd = 5, col="blue1")
#list(basis=mBmat)
}
t <- c(0, 0.525, 0.875); generate_spline(t)
set.seed(12)
library(TBASS)
f <- function(x){
10*sin(pi*x[,1]*x[,2]) + 20*(x[,3]-.5)^2 + 10*x[,4] + 5*x[,5]
}
sigma <- 1 # TRUE noise sd
n <- 1000 # number of observations
x <- matrix(runif(n*5), nrow = n, ncol = 5)
y <- rnorm(n, mean = f(x), sd = sigma)
ind <- sample(n,size=10) # convert 10 points to outliers
y[ind] <- rnorm(5, f(x[ind,]), 15)
col <- rep(1,n) # for coloring these points in a later plot
col[ind] <- 2
nmcmc <- 1000 #number of iterations
tb <- tbass(x, y, nu = 10, nmcmc = nmcmc, verbose = TRUE)
##------ Fri Aug 28 15:19:23 2020 ------##
##------ Fri Aug 28 15:19:26 2020 ------##
##------ Fri Aug 28 15:19:30 2020 ------##
##------ Fri Aug 28 15:19:34 2020 ------##
##------ Fri Aug 28 15:19:37 2020 ------##
##------ Fri Aug 28 15:19:41 2020 ------##
##------ Fri Aug 28 15:19:45 2020 ------##
##------ Fri Aug 28 15:19:48 2020 ------##
##------ Fri Aug 28 15:19:52 2020 ------##
##------ Fri Aug 28 15:19:55 2020 ------##
plot(tb$nbasis, type = "l", main = "Trace plot of number of basis functions")
plot(tb$X %*% tb$beta, y, col = col, main="Predicted vs Actual Values")
plot(tb$X %*% tb$b, y, col = col, main="Predicted vs Actual Values")
abline(0,1,col="blue2",lwd=2.5)
burn_final <- nmcmc/10
burn <- 1:burn_final
plot(
sqrt(tb$s2[-burn]),
type = "l",
main = "Plot of sigma"
)
matplot(
sqrt(1/tb$v[seq(burn_final,nmcmc,100),]),
type='l',
main = expression(paste("Plot of ",V[i]))
)
tb$nbasis
n <- 300
x <- seq(0,1,length.out=n)
y <- sin(2 * pi * x^2) * 10 + rnorm(n)
p<-plot(x,y,main=paste0("Figure ",fig," : Univariate Nonlinear Data"))
fig <- fig + 1
generate_spline <- function(tvec, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis functions
}
mBmat <- t(Bmat)
mod <- lm(y ~ mBmat) #use gibbs to sample coefs in bayes
pred <- predict(mod)
plot(x,y,main=paste0("Figure ",fig," : Univariate Spline Function"))
lines(x, pred, type = "l", lwd = 5, col="blue1")
#list(basis=mBmat)
}
t <- c(0, 0.525, 0.875); p2<-generate_spline(t)
generate_spline <- function(tvec, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis functions
}
mBmat <- t(Bmat)
mod <- lm(y ~ mBmat) #use gibbs to sample coefs in bayes
pred <- predict(mod)
plot(x,y,main=paste0("Figure ",2," : Univariate Spline Function"))
lines(x, pred, type = "l", lwd = 5, col="blue1")
#list(basis=mBmat)
}
t <- c(0, 0.525, 0.875); p2<-generate_spline(t)
knitr::opts_chunk$set(
collapse = TRUE,
echo = TRUE,
comment = "#>"
)
library(TBASS)
# rmarkdown::html_vignette
fig <- 1
n <- 300
x <- seq(0,1,length.out=n)
y <- sin(2 * pi * x^2) * 10 + rnorm(n)
generate_spline <- function(tvec, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis functions
}
mBmat <- t(Bmat)
mod <- lm(y ~ mBmat) #use gibbs to sample coefs in bayes
pred <- predict(mod)
plot(x,y,main=paste0("Figure ",2," : Univariate Spline Function"))
lines(x, pred, type = "l", lwd = 5, col="blue1")
#list(basis=mBmat)
}
t <- c(0, 0.525, 0.875)
x <- 1:5
x
c(1,3,5)
cumsum(c(1,5,7))
summary(x)
fivenum(x)
tbass
library(TBASS)
tbass
